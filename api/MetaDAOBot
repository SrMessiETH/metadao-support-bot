# Build the application (once, outside handler)
application = Application.builder().token(BOT_TOKEN).build()

# Conversation handler (updated entry point for callback)
conv_handler = ConversationHandler(
    entry_points=[CallbackQueryHandler(support_start, pattern='^support_request$')],
    states={
        NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_name)],
        EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_email)],
        QUESTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_question)],
    },
    fallbacks=[],
)

# Add handlers
application.add_handler(CallbackQueryHandler(button_handler))
application.add_handler(MessageHandler(filters.Regex(r'^(CA|ca|Ca)$'), handle_ca))
application.add_handler(conv_handler)
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, text_handler))
application.add_handler(MessageHandler(filters.COMMAND, text_handler))  # Handle commands as text

# Vercel serverless function handler for Telegram webhook
from http.server import BaseHTTPRequestHandler
import asyncio
import json
from telegram.ext import Application, Update, CallbackQueryHandler, MessageHandler, filters
from telegram import logger

def handler(environ, start_response):
    """Vercel serverless function handler for Telegram webhook"""
    
    # Get request method
    method = environ.get('REQUEST_METHOD', 'GET')
    
    if method == 'POST':
        try:
            # Read the incoming request body
            content_length = int(environ.get('CONTENT_LENGTH', 0))
            post_data = environ['wsgi.input'].read(content_length)
            
            # Parse the JSON update from Telegram
            update_data = json.loads(post_data.decode('utf-8'))
            logger.info(f"[v0] Received update: {update_data}")
            
            # Convert to Telegram Update object
            update = Update.de_json(update_data, application.bot)
            
            # Process the update asynchronously
            asyncio.run(application.process_update(update))
            
            # Send success response
            status = '200 OK'
            headers = [('Content-type', 'application/json')]
            start_response(status, headers)
            return [json.dumps({"ok": True}).encode()]
            
        except Exception as e:
            logger.error(f"[v0] Error processing update: {e}", exc_info=True)
            status = '500 Internal Server Error'
            headers = [('Content-type', 'application/json')]
            start_response(status, headers)
            return [json.dumps({"ok": False, "error": str(e)}).encode()]
    
    elif method == 'GET':
        # Health check endpoint
        status = '200 OK'
        headers = [('Content-type', 'text/plain')]
        start_response(status, headers)
        return [b"MetaDAO Support Bot is running on Vercel!"]
    
    else:
        # Method not allowed
        status = '405 Method Not Allowed'
        headers = [('Content-type', 'text/plain')]
        start_response(status, headers)
        return [b"Method not allowed"]
