# Build the application (once, outside handler)
application = Application.builder().token(BOT_TOKEN).build()

# Conversation handler (updated entry point for callback)
conv_handler = ConversationHandler(
    entry_points=[CommandHandler('start', start)],
    states={
        MAIN_MENU: [
            CallbackQueryHandler(handle_main_menu)
        ],
        SUPPORT_MENU: [
            CallbackQueryHandler(handle_support_menu)
        ],
        WAITING_FOR_QUESTION: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_question)
        ],
        WAITING_FOR_FEEDBACK: [
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_feedback)
        ],
    },
    fallbacks=[CommandHandler('start', start)],
)

# Add handlers
application.add_handler(CallbackQueryHandler(button_handler))
application.add_handler(MessageHandler(filters.Regex(r'^(CA|ca|Ca)$'), handle_ca))
application.add_handler(conv_handler)
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, text_handler))
application.add_handler(MessageHandler(filters.COMMAND, text_handler))  # Handle commands as text

# Vercel serverless function handler for Telegram webhook
import json
from telegram.ext import Application, Update, CallbackQueryHandler, MessageHandler, filters, CommandHandler
import asyncio
import logging

logger = logging.getLogger(__name__)

def handler(environ, start_response):
    """Vercel WSGI handler for Telegram webhook"""
    try:
        # Get request method
        method = environ.get('REQUEST_METHOD', 'GET')
        
        if method == 'POST':
            # Read request body
            try:
                content_length = int(environ.get('CONTENT_LENGTH', 0))
            except ValueError:
                content_length = 0
            
            request_body = environ['wsgi.input'].read(content_length)
            
            # Parse JSON update from Telegram
            update_data = json.loads(request_body.decode('utf-8'))
            update = Update.de_json(update_data, application.bot)
            
            # Process the update asynchronously
            asyncio.run(application.process_update(update))
            
            # Return success response
            status = '200 OK'
            headers = [('Content-Type', 'application/json')]
            start_response(status, headers)
            return [json.dumps({"ok": True}).encode('utf-8')]
            
        elif method == 'GET':
            # Health check endpoint
            status = '200 OK'
            headers = [('Content-Type', 'text/plain')]
            start_response(status, headers)
            return [b'MetaDAO Bot is running!']
        
        else:
            # Method not allowed
            status = '405 Method Not Allowed'
            headers = [('Content-Type', 'text/plain')]
            start_response(status, headers)
            return [b'Method Not Allowed']
            
    except Exception as e:
        logger.error(f"Handler error: {e}")
        status = '500 Internal Server Error'
        headers = [('Content-Type', 'application/json')]
        start_response(status, headers)
        return [json.dumps({"ok": False, "error": str(e)}).encode('utf-8')]
